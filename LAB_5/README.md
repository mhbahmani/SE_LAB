# Lab 5
### Software Engineering
- Ali Shirmohammadi 97106068
- Mohammad Hosein Bahmani 97105811

<div dir="rtl">

### جزئیات پیاده سازی:
- ابتدا در Intellij یک پروژه Maven خالی ایجاد کرده و JUnit را به آن اضافه می‌کنیم [4e8f3f9](https://github.com/mhbahmani/SE_LAB/commit/4e8f3f91a60182f72370c868954fe5a6fee02bb4)
- سپس تستی می‌نویسیم که در آن در کلاس Rectangle متد computeArea را صدا بزنیم و با توجه به طول و عرض داده شده مساحت آن را به درستی حساب کنیم. [6d7e660](https://github.com/mhbahmani/SE_LAB/commit/6d7e6604919ee4769e0841a96d9e505c88d22882)
- سپس در صورتی که سعی کنیم تست را اجرا کنیم متوجه می‌شویم که کد نوشته شده با خطای کامپایل مواجه است. برای رفع این خطا کلاس Rectangle را ایجاد کرده و تابع مورد نظر را در آن قرار می‌دهیم (فعلا چیزی پیاده سازی نمی‌کنیم) [117a365](https://github.com/mhbahmani/SE_LAB/commit/117a3659aacf19c980f0c9bd765c211194929cce)
- سپس تست را اجرا می‌کنیم و متوجه می‌شویم چون هنوز چیزی پیاده سازی نکرده ایم تست‌ها رد می‌شوند. بدین منظور تابع محاسبه مساحت در کلاس مستطیل را پیاده سای می‌کنیم. [303f9ab](https://github.com/mhbahmani/SE_LAB/commit/303f9ab5168feb40d4d529bac2e1115bcb961c8d)
- سپس به همین ترتیب و به روش TDD، باید قابلیت‌ها و سایل Featureهای مورد انتظار شامل ساختن شیء از کلاس مستطیل و محاسبه مساحت مستطیل ساخته شده، تغییر طول و عرض یک شیء و ساختن کلاس مربع به طوری که از کلاس مستطیلی ارث بری کند را پیاده سازی نمائیم.

### پرسش اول: معرفی اصول SOLID

1. Single Responsibility Principle:  
اصل یکتایی مسئولیت، به این معناست که هر کلاس یا ماژول باید فقط یک وظیفه داشته باشد. رعایت این اصل در طراحی باعث می‌شود که کد راحت‌تر تست بشود و همینطوری نگهداری و maintain کد نیز راحت‌تر بشود.  
2. Open/Closed Principle:  
اصل باز/بسته بودن، بیان می‌کند که کلاس‌ها باید نسبت به توسعه باز باشد، اما نسبت به تغییر بسته باشد. چرا که تغییر کلاس‌هایی که تست شده‌اند و از عملکرد آن‌ها مطمئن هستیم، می‌تواند منجر به تولید باگ شود. اما در هر زمان می‌توان رفتار کلاس را توسعه داد و به آن افزود.  
3. Liskov Substitution Principle:  
این اصل اشاره به این نکته دارد که کلاس‌ پدر باید بتواند بدون خراب شدن عملکرد برنامه، با کلاس‌های فرزندش جایگزین شود.  
4. Interface Segregation Principle:  
این اصل بر این عقیده است که کلاینت نباید وابسته به interfaceهایی باشد که از آن‌ها استفاده نمی‌کند. در واقع منظور این است که اینترفیس‌های کوچک‌تری داشته باشیم که کلاینت فقط از آن‌هایی که لازم باشد استفاده کند و نیاز به پیاده‌سازی تمامی رابط‌ها نداشته باشد.  
5. Dependency Inversion Principle:  
این اصل راهی برای جدا کردن ماژول‌های نرم‌افزاری ارائه می‌کند. به بیان دیگر، این اصل به این معناست که ماژول‌های سطح بالا نباید به ماژول‌های سطح پایین وابستگی داشته باشند.  

</div>